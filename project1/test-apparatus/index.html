<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AdFlow Test Apparatus</title>
    <!-- AWS SDK v2 browser bundle -->
    <script src="https://sdk.amazonaws.com/js/aws-sdk-2.1692.0.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background-color: #f8fafc;
            color: #1e293b;
            line-height: 1.6;
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            color: #1e40af;
            margin-bottom: 5px;
            font-size: 24px;
        }

        h2 {
            color: #1e40af;
            border-left: 4px solid #3b82f6;
            padding-left: 15px;
            margin-top: 30px;
            margin-bottom: 15px;
            font-size: 18px;
        }

        label {
            display: block;
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 4px;
            color: #1e293b;
        }

        input,
        select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #cbd5e1;
            border-radius: 6px;
            font-size: 14px;
            margin-bottom: 12px;
            background: #fff;
            color: #1e293b;
        }

        input:focus,
        select:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.15);
        }

        input[readonly] {
            background: #f1f5f9;
            color: #64748b;
        }

        button {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.15s;
        }

        .btn-primary {
            background: #1e40af;
            color: #fff;
        }

        .btn-primary:hover {
            background: #1d4ed8;
        }

        .btn-primary:disabled {
            background: #94a3b8;
            cursor: not-allowed;
        }

        .btn-danger {
            background: #dc2626;
            color: #fff;
        }

        .btn-danger:hover {
            background: #b91c1c;
        }

        .btn-secondary {
            background: #e2e8f0;
            color: #1e293b;
        }

        .btn-secondary:hover {
            background: #cbd5e1;
        }

        .card {
            background: #fff;
            border: 1px solid #cbd5e1;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .card-blue {
            background: #dbeafe;
            border-color: #93c5fd;
        }

        .card-green {
            background: #d1fae5;
            border-color: #10b981;
        }

        .card-yellow {
            background: #fef3c7;
            border-color: #f59e0b;
        }

        .grid-2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
        }

        .grid-3 {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 16px;
        }

        .grid-4 {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr;
            gap: 12px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 10px 0;
            font-size: 14px;
            border: 1px solid #cbd5e1;
        }

        th {
            padding: 10px 12px;
            text-align: left;
            background: #f1f5f9;
            color: #1e40af;
            border: 1px solid #cbd5e1;
            font-weight: 600;
        }

        td {
            padding: 8px 12px;
            border: 1px solid #cbd5e1;
        }

        tr:nth-child(even) {
            background: #f8fafc;
        }

        .mono {
            font-family: 'Courier New', monospace;
            font-size: 13px;
        }

        .status-bar {
            background: #1e293b;
            color: #e2e8f0;
            padding: 8px 15px;
            border-radius: 6px;
            font-family: monospace;
            font-size: 13px;
            margin: 10px 0;
            min-height: 36px;
        }

        .progress-container {
            background: #e2e8f0;
            border-radius: 4px;
            height: 24px;
            margin: 10px 0;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background: #3b82f6;
            border-radius: 4px;
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-size: 12px;
            font-weight: 600;
        }

        .subtitle {
            color: #64748b;
            font-size: 14px;
            margin-bottom: 20px;
        }

        .btn-group {
            display: flex;
            gap: 8px;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        .metric-value {
            font-size: 28px;
            font-weight: 700;
            color: #1e40af;
        }

        .metric-label {
            font-size: 12px;
            color: #64748b;
            text-transform: uppercase;
        }

        .log-area {
            background: #1e293b;
            color: #e2e8f0;
            padding: 12px;
            border-radius: 6px;
            font-family: monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
            white-space: pre-wrap;
        }

        .cred-note {
            font-size: 12px;
            color: #64748b;
            margin-top: -8px;
            margin-bottom: 12px;
        }

        .connected-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
        }

        .badge-ok {
            background: #d1fae5;
            color: #065f46;
        }

        .badge-err {
            background: #fee2e2;
            color: #991b1b;
        }

        .badge-wait {
            background: #fef3c7;
            color: #92400e;
        }

        .password-field {
            -webkit-text-security: disc;
        }

        @media (max-width: 768px) {

            .grid-2,
            .grid-3,
            .grid-4 {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>

<body>

    <h1>AdFlow Test Apparatus</h1>
    <p class="subtitle">Distributed Systems for Data Science - Ad Selection Pipeline Testing</p>

    <!-- AWS Credentials -->
    <div class="card card-green">
        <h2 style="margin-top:0; border-left:none; padding-left:0;">AWS Credentials</h2>
        <p class="cred-note">Your credentials stay in this browser tab. Click "Save Config" to remember them in your
            browser's local storage for next time.</p>
        <div class="grid-3">
            <div>
                <label for="accessKeyId">Access Key ID</label>
                <input type="text" id="accessKeyId" placeholder="AKIA..." autocomplete="off">
            </div>
            <div>
                <label for="secretAccessKey">Secret Access Key</label>
                <input type="text" id="secretAccessKey" class="password-field" placeholder="Your secret key"
                    autocomplete="off">
            </div>
            <div>
                <label for="region">AWS Region</label>
                <select id="region">
                    <option value="us-east-1" selected>us-east-1</option>
                    <option value="us-east-2">us-east-2</option>
                    <option value="us-west-1">us-west-1</option>
                    <option value="us-west-2">us-west-2</option>
                </select>
            </div>
        </div>
        <div class="btn-group">
            <button class="btn-primary" onclick="testConnection()">Test Connection</button>
            <button class="btn-secondary" onclick="saveConfig()">Save Config</button>
            <button class="btn-secondary" onclick="clearSavedConfig()">Clear Saved</button>
            <span id="connectionStatus" class="connected-badge badge-wait">Not tested</span>
            <span id="saveStatus" style="font-size:12px; color:#64748b;"></span>
        </div>
    </div>

    <!-- Configuration -->
    <div class="card card-blue">
        <h2 style="margin-top:0; border-left:none; padding-left:0;">Configuration</h2>
        <div class="grid-3">
            <div>
                <label for="studentId">Student ID</label>
                <input type="text" id="studentId" placeholder="e.g. gsalu" value="">
            </div>
            <div>
                <label for="seed">Random Seed</label>
                <input type="number" id="seed" value="42">
            </div>
            <div>
                <label>Input Queue URL (auto-generated)</label>
                <input type="text" id="inputQueueUrl" readonly class="mono" placeholder="Enter Student ID above">
            </div>
        </div>
        <div class="grid-2">
            <div>
                <label>Results Queue URL (auto-generated)</label>
                <input type="text" id="resultsQueueUrl" readonly class="mono" placeholder="Enter Student ID above">
            </div>
            <div>
                <label>DynamoDB Table Name (auto-generated)</label>
                <input type="text" id="tableName" readonly class="mono" placeholder="Enter Student ID above">
            </div>
        </div>
    </div>

    <!-- Test Profiles -->
    <div class="card">
        <h2 style="margin-top:0; border-left:none; padding-left:0;">Test Profile</h2>
        <div class="grid-3">
            <div>
                <label for="profile">Profile</label>
                <select id="profile">
                    <option value="warmup">Warmup (10 msgs, slow)</option>
                    <option value="steady">Steady (100 msgs, moderate)</option>
                    <option value="burst" selected>Burst (500 msgs, all at once)</option>
                    <option value="ramp">Ramp (500 msgs, accelerating)</option>
                    <option value="soak">Soak (200 msgs, sustained)</option>
                    <option value="custom">Custom</option>
                </select>
            </div>
            <div>
                <label for="msgCount">Message Count</label>
                <input type="number" id="msgCount" value="500" min="1" max="5000">
            </div>
            <div>
                <label for="batchDelay">Delay Between Batches (ms)</label>
                <input type="number" id="batchDelay" value="0" min="0" max="10000">
            </div>
        </div>

        <div class="btn-group">
            <button class="btn-primary" id="btnRun" onclick="runTest()">Run Test</button>
            <button class="btn-secondary" id="btnStop" onclick="stopTest()" disabled>Stop</button>
            <button class="btn-secondary" onclick="startPolling()">Poll Results Only</button>
        </div>
    </div>

    <!-- Live Metrics -->
    <div class="card">
        <h2 style="margin-top:0; border-left:none; padding-left:0;">Live Metrics</h2>
        <div class="grid-4">
            <div style="text-align:center;">
                <div class="metric-value" id="metricSent">0</div>
                <div class="metric-label">Sent</div>
            </div>
            <div style="text-align:center;">
                <div class="metric-value" id="metricReceived">0</div>
                <div class="metric-label">Received</div>
            </div>
            <div style="text-align:center;">
                <div class="metric-value" id="metricAvgLatency">--</div>
                <div class="metric-label">Avg Latency</div>
            </div>
            <div style="text-align:center;">
                <div class="metric-value" id="metricThroughput">--</div>
                <div class="metric-label">Results/sec</div>
            </div>
        </div>
        <div class="progress-container">
            <div class="progress-bar" id="progressBar" style="width:0%;">0%</div>
        </div>
        <div class="status-bar" id="statusBar">Ready. Configure your credentials and student ID, then select a test
            profile.</div>
    </div>

    <!-- Performance Stats -->
    <div class="card">
        <h2 style="margin-top:0; border-left:none; padding-left:0;">Performance Stats
            <span style="font-size:12px; font-weight:400; color:#64748b; font-family:monospace;">— latency = time from
                SQS send to processed_at in result</span>
        </h2>

        <!-- Stat boxes -->
        <div class="grid-4" style="margin-bottom:16px;">
            <div style="text-align:center; background:#f1f5f9; border-radius:6px; padding:12px;">
                <div style="font-size:22px; font-weight:700; color:#065f46;" id="perfMin">--</div>
                <div class="metric-label">Min</div>
            </div>
            <div style="text-align:center; background:#f1f5f9; border-radius:6px; padding:12px;">
                <div style="font-size:22px; font-weight:700; color:#1e40af;" id="perfAvg">--</div>
                <div class="metric-label">Avg</div>
            </div>
            <div style="text-align:center; background:#f1f5f9; border-radius:6px; padding:12px;">
                <div style="font-size:22px; font-weight:700; color:#92400e;" id="perfP95">--</div>
                <div class="metric-label">p95</div>
            </div>
            <div style="text-align:center; background:#f1f5f9; border-radius:6px; padding:12px;">
                <div style="font-size:22px; font-weight:700; color:#991b1b;" id="perfMax">--</div>
                <div class="metric-label">Max</div>
            </div>
        </div>

        <!-- Latency bucket bar -->
        <div style="margin-bottom:6px;">
            <div style="font-size:12px; font-weight:600; color:#475569; margin-bottom:4px;">Latency distribution —
                target: &lt;500 ms</div>
            <div style="display:flex; height:28px; border-radius:4px; overflow:hidden; background:#f1f5f9;">
                <div id="bucketFast"
                    style="background:#059669; display:flex; align-items:center; justify-content:center; transition:width 0.4s; min-width:0; overflow:hidden;">
                    <span id="bucketFastLbl"
                        style="font-size:11px; font-weight:600; color:#fff; white-space:nowrap; padding:0 4px;"></span>
                </div>
                <div id="bucketOk"
                    style="background:#d97706; display:flex; align-items:center; justify-content:center; transition:width 0.4s; min-width:0; overflow:hidden;">
                    <span id="bucketOkLbl"
                        style="font-size:11px; font-weight:600; color:#fff; white-space:nowrap; padding:0 4px;"></span>
                </div>
                <div id="bucketSlow"
                    style="background:#dc2626; display:flex; align-items:center; justify-content:center; transition:width 0.4s; min-width:0; overflow:hidden;">
                    <span id="bucketSlowLbl"
                        style="font-size:11px; font-weight:600; color:#fff; white-space:nowrap; padding:0 4px;"></span>
                </div>
            </div>
            <div style="display:flex; gap:16px; margin-top:4px; font-size:11px; color:#64748b;">
                <span style="color:#059669;">&#9632; &lt;500 ms (target)</span>
                <span style="color:#d97706;">&#9632; 500 ms – 1 s</span>
                <span style="color:#dc2626;">&#9632; &gt;1 s (slow)</span>
            </div>
        </div>

        <!-- Sparkline -->
        <div style="margin-top:14px;">
            <div style="font-size:12px; font-weight:600; color:#475569; margin-bottom:4px;">Recent latency (last 60
                results) — dashed line = 500 ms target</div>
            <canvas id="sparkCanvas" width="760" height="60"
                style="width:100%; height:60px; border:1px solid #e2e8f0; border-radius:4px; background:#f8fafc;"></canvas>
        </div>
    </div>

    <!-- Results Table -->
    <div class="card">
        <h2 style="margin-top:0; border-left:none; padding-left:0;">Results</h2>
        <div style="max-height:300px; overflow-y:auto;">
            <table>
                <thead>
                    <tr>
                        <th>Opportunity ID</th>
                        <th>Winner</th>
                        <th>Bid ($)</th>
                        <th>Score</th>
                        <th>Margin</th>
                        <th>Latency</th>
                        <th>Processed At</th>
                    </tr>
                </thead>
                <tbody id="resultsBody">
                </tbody>
            </table>
        </div>
        <p style="color:#64748b; font-size:13px; margin-top:8px;">
            Showing most recent results. Table updates as results arrive from the results queue.
        </p>
    </div>

    <!-- DynamoDB Table Viewer -->
    <div class="card">
        <h2 style="margin-top:0; border-left:none; padding-left:0;">DynamoDB Table Contents</h2>
        <div class="btn-group" style="margin-bottom:10px;">
            <button class="btn-primary" onclick="scanDynamoTable()">Scan Table</button>
            <span id="scanStatus" style="font-size:13px; color:#64748b; align-self:center;"></span>
        </div>
        <div style="max-height:400px; overflow-y:auto;">
            <table>
                <thead>
                    <tr>
                        <th>Opportunity ID</th>
                        <th>Winner</th>
                        <th>Winning Bid</th>
                        <th>Winning Score</th>
                        <th>Score Margin</th>
                        <th>Content Category</th>
                        <th>Region</th>
                        <th>Device</th>
                        <th>Num Bids</th>
                        <th>Processed At</th>
                    </tr>
                </thead>
                <tbody id="dynamoBody">
                </tbody>
            </table>
        </div>
        <p style="color:#64748b; font-size:13px; margin-top:8px;">
            Click "Scan Table" to read all records from the DynamoDB results table.
        </p>
    </div>

    <!-- Cleanup -->
    <div class="card card-yellow">
        <h2 style="margin-top:0; border-left:none; padding-left:0;">Cleanup</h2>
        <p style="font-size:14px;">Clear queues and table between test runs. DynamoDB cleanup deletes and recreates the
            table.</p>
        <div class="btn-group">
            <button class="btn-danger" onclick="purgeInputQueue()">Purge Input Queue</button>
            <button class="btn-danger" onclick="purgeResultsQueue()">Purge Results Queue</button>
            <button class="btn-danger" onclick="cleanupTable()">Recreate DynamoDB Table</button>
            <button class="btn-danger" onclick="fullCleanup()">Full Cleanup (All)</button>
        </div>
    </div>

    <!-- Activity Log -->
    <div class="card">
        <h2 style="margin-top:0; border-left:none; padding-left:0;">Activity Log</h2>
        <div class="log-area" id="logArea">AdFlow Test Apparatus initialized (client-side mode).
        </div>
    </div>

    <script>
        // =====================================================================
        // State
        // =====================================================================
        let testRunning = false;
        let pollInterval = null;
        let sentCount = 0;
        let receivedCount = 0;
        let latencies = [];
        let testStartTime = null;
        let generatedMessages = [];
        let sendTimes = new Map(); // opportunity_id -> epoch ms when sent to SQS
        let sqsClient = null;
        let dynamoClient = null;

        // =====================================================================
        // AWS Client Setup
        // =====================================================================
        function getAwsConfig() {
            const accessKeyId = document.getElementById('accessKeyId').value.trim();
            const secretAccessKey = document.getElementById('secretAccessKey').value.trim();
            const region = document.getElementById('region').value;
            if (!accessKeyId || !secretAccessKey) return null;
            return { accessKeyId, secretAccessKey, region };
        }

        function initClients() {
            const cfg = getAwsConfig();
            if (!cfg) {
                log('ERROR: Enter your AWS Access Key ID and Secret Access Key.');
                return false;
            }
            AWS.config.update({
                region: cfg.region,
                accessKeyId: cfg.accessKeyId,
                secretAccessKey: cfg.secretAccessKey,
            });
            sqsClient = new AWS.SQS();
            dynamoClient = new AWS.DynamoDB();
            return true;
        }

        async function testConnection() {
            const badge = document.getElementById('connectionStatus');
            badge.textContent = 'Testing...';
            badge.className = 'connected-badge badge-wait';

            if (!initClients()) {
                badge.textContent = 'Missing credentials';
                badge.className = 'connected-badge badge-err';
                return;
            }

            try {
                await sqsClient.listQueues({ MaxResults: 1 }).promise();
                badge.textContent = 'Connected';
                badge.className = 'connected-badge badge-ok';
                log('AWS connection successful.');
            } catch (e) {
                badge.textContent = 'Failed: ' + e.code;
                badge.className = 'connected-badge badge-err';
                log('AWS connection failed: ' + e.message);
            }
        }

        // =====================================================================
        // Configuration auto-fill
        // =====================================================================
        document.getElementById('studentId').addEventListener('input', updateConfig);
        document.getElementById('region').addEventListener('change', updateConfig);
        document.getElementById('profile').addEventListener('change', updateProfile);

        function updateConfig() {
            const sid = document.getElementById('studentId').value.trim().toLowerCase();
            const region = document.getElementById('region').value;

            if (sid) {
                // Build queue names -- the server will resolve them to full URLs
                // via SQS getQueueUrl when needed
                document.getElementById('inputQueueUrl').value = 'adflow-' + sid + '-input';
                document.getElementById('resultsQueueUrl').value = 'adflow-' + sid + '-results';
                document.getElementById('tableName').value = 'adflow-' + sid + '-results';
            } else {
                document.getElementById('inputQueueUrl').value = '';
                document.getElementById('resultsQueueUrl').value = '';
                document.getElementById('tableName').value = '';
            }
        }

        const PROFILES = {
            warmup: { count: 10, delay: 500 },
            steady: { count: 100, delay: 100 },
            burst: { count: 500, delay: 0 },
            ramp: { count: 500, delay: 0 },
            soak: { count: 200, delay: 1000 },
            custom: { count: null, delay: null },
        };

        function updateProfile() {
            const profile = document.getElementById('profile').value;
            const cfg = PROFILES[profile];
            if (cfg.count !== null) {
                document.getElementById('msgCount').value = cfg.count;
                document.getElementById('batchDelay').value = cfg.delay;
            }
        }

        // =====================================================================
        // Queue URL resolution
        // =====================================================================
        async function resolveQueueUrl(nameOrUrl) {
            if (!nameOrUrl) return null;
            if (nameOrUrl.startsWith('https://')) return nameOrUrl;
            // It is a queue name -- resolve via getQueueUrl
            const resp = await sqsClient.getQueueUrl({ QueueName: nameOrUrl }).promise();
            return resp.QueueUrl;
        }

        // =====================================================================
        // Logging
        // =====================================================================
        function log(msg) {
            const area = document.getElementById('logArea');
            const ts = new Date().toLocaleTimeString();
            area.textContent += '[' + ts + '] ' + msg + '\n';
            area.scrollTop = area.scrollHeight;
        }

        function setStatus(msg) {
            document.getElementById('statusBar').textContent = msg;
        }

        // =====================================================================
        // Opportunity Generator (ported from Python simulator)
        // =====================================================================
        const ADVERTISERS = [
            { advertiser_id: "adv_sportswear_01", category: "sportswear", bid_min: 2.00, bid_max: 5.50 },
            { advertiser_id: "adv_sportswear_02", category: "sportswear", bid_min: 1.50, bid_max: 4.00 },
            { advertiser_id: "adv_energy_01", category: "energy_drink", bid_min: 2.50, bid_max: 6.00 },
            { advertiser_id: "adv_energy_02", category: "energy_drink", bid_min: 1.80, bid_max: 4.50 },
            { advertiser_id: "adv_fintech_01", category: "fintech", bid_min: 3.00, bid_max: 8.00 },
            { advertiser_id: "adv_fintech_02", category: "fintech", bid_min: 2.00, bid_max: 5.00 },
            { advertiser_id: "adv_insurance_01", category: "insurance", bid_min: 3.50, bid_max: 7.00 },
            { advertiser_id: "adv_insurance_02", category: "insurance", bid_min: 2.00, bid_max: 5.50 },
            { advertiser_id: "adv_streaming_01", category: "streaming", bid_min: 2.50, bid_max: 6.50 },
            { advertiser_id: "adv_streaming_02", category: "streaming", bid_min: 1.50, bid_max: 4.00 },
            { advertiser_id: "adv_gaming_01", category: "gaming", bid_min: 2.00, bid_max: 5.00 },
            { advertiser_id: "adv_gaming_02", category: "gaming", bid_min: 1.00, bid_max: 3.50 },
            { advertiser_id: "adv_beauty_01", category: "beauty", bid_min: 2.50, bid_max: 5.50 },
            { advertiser_id: "adv_beauty_02", category: "beauty", bid_min: 1.50, bid_max: 4.00 },
            { advertiser_id: "adv_travel_01", category: "travel", bid_min: 3.00, bid_max: 7.50 },
            { advertiser_id: "adv_travel_02", category: "travel", bid_min: 2.00, bid_max: 5.00 },
            { advertiser_id: "adv_fastfood_01", category: "fast_food", bid_min: 3.50, bid_max: 7.00 },
            { advertiser_id: "adv_fastfood_02", category: "fast_food", bid_min: 2.50, bid_max: 6.00 },
            { advertiser_id: "adv_auto_01", category: "automotive", bid_min: 4.00, bid_max: 8.00 },
            { advertiser_id: "adv_auto_02", category: "automotive", bid_min: 3.00, bid_max: 6.50 },
            { advertiser_id: "adv_telecom_01", category: "telecom", bid_min: 3.00, bid_max: 6.00 },
            { advertiser_id: "adv_retail_01", category: "retail", bid_min: 1.50, bid_max: 4.50 },
            { advertiser_id: "adv_retail_02", category: "retail", bid_min: 1.00, bid_max: 3.00 },
        ];

        const CONTENT_CATEGORIES = ["sports", "news", "entertainment", "finance", "lifestyle"];
        const CONTENT_WEIGHTS = [0.25, 0.15, 0.25, 0.20, 0.15];
        const DEVICES = ["mobile", "desktop"];
        const DEVICE_WEIGHTS = [0.70, 0.30];
        const REGIONS = ["northeast", "southeast", "midwest", "west", "international"];
        const REGION_WEIGHTS = [0.20, 0.25, 0.20, 0.25, 0.10];
        const HOUR_WEIGHTS = [
            0.5, 0.3, 0.2, 0.2, 0.3, 0.5,
            1.5, 2.0, 2.0, 1.5, 1.2, 1.0,
            1.8, 1.8, 1.2, 1.0, 1.0, 1.2,
            1.5, 2.0, 2.5, 2.5, 2.0, 1.0,
        ];

        // Seeded PRNG (mulberry32)
        function mulberry32(seed) {
            let s = seed | 0;
            return function () {
                s = (s + 0x6D2B79F5) | 0;
                let t = Math.imul(s ^ (s >>> 15), 1 | s);
                t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;
                return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
            };
        }

        function weightedChoice(rng, items, weights) {
            const total = weights.reduce((a, b) => a + b, 0);
            let r = rng() * total;
            let cumulative = 0;
            for (let i = 0; i < items.length; i++) {
                cumulative += weights[i];
                if (r <= cumulative) return items[i];
            }
            return items[items.length - 1];
        }

        function rngInt(rng, min, max) {
            return Math.floor(rng() * (max - min + 1)) + min;
        }

        function rngUniform(rng, min, max) {
            return min + rng() * (max - min);
        }

        function rngSample(rng, arr, count) {
            const copy = arr.slice();
            const n = Math.min(count, copy.length);
            for (let i = copy.length - 1; i > 0; i--) {
                const j = Math.floor(rng() * (i + 1));
                [copy[i], copy[j]] = [copy[j], copy[i]];
            }
            return copy.slice(0, n);
        }

        function generateUUID(rng) {
            const hex = '0123456789abcdef';
            let uuid = '';
            for (let i = 0; i < 32; i++) {
                uuid += hex[Math.floor(rng() * 16)];
            }
            return uuid.substring(0, 8) + '-' + uuid.substring(8, 12) + '-4' +
                uuid.substring(13, 16) + '-' + hex[8 + Math.floor(rng() * 4)] +
                uuid.substring(17, 20) + '-' + uuid.substring(20, 32);
        }

        function generateTimestamp(rng) {
            const hours = [];
            for (let i = 0; i < 24; i++) hours.push(i);
            const hour = weightedChoice(rng, hours, HOUR_WEIGHTS);
            const minute = rngInt(rng, 0, 59);
            const second = rngInt(rng, 0, 59);
            const pad = (n) => String(n).padStart(2, '0');
            return '2025-03-10T' + pad(hour) + ':' + pad(minute) + ':' + pad(second) + 'Z';
        }

        function generateOpportunity(rng) {
            const numBids = rngInt(rng, 3, 8);
            const bidders = rngSample(rng, ADVERTISERS, numBids);
            return {
                opportunity_id: generateUUID(rng),
                timestamp: generateTimestamp(rng),
                user_id: 'u_' + rngInt(rng, 10000, 99999),
                content_category: weightedChoice(rng, CONTENT_CATEGORIES, CONTENT_WEIGHTS),
                device_type: weightedChoice(rng, DEVICES, DEVICE_WEIGHTS),
                region: weightedChoice(rng, REGIONS, REGION_WEIGHTS),
                bids: bidders.map(adv => ({
                    advertiser_id: adv.advertiser_id,
                    bid_amount: Math.round(rngUniform(rng, adv.bid_min, adv.bid_max) * 100) / 100,
                    category: adv.category,
                })),
            };
        }

        function generateOpportunities(count, seed) {
            const rng = mulberry32(seed);
            const result = [];
            for (let i = 0; i < count; i++) {
                result.push(generateOpportunity(rng));
            }
            return result;
        }

        // =====================================================================
        // Core test flow
        // =====================================================================
        async function runTest() {
            if (!initClients()) return;

            const inputQName = document.getElementById('inputQueueUrl').value.trim();
            const resultsQName = document.getElementById('resultsQueueUrl').value.trim();

            if (!inputQName || !resultsQName) {
                log('ERROR: Enter your Student ID first.');
                return;
            }

            const count = parseInt(document.getElementById('msgCount').value) || 500;
            const delay = parseInt(document.getElementById('batchDelay').value) || 0;
            const seed = parseInt(document.getElementById('seed').value) || 42;
            const profile = document.getElementById('profile').value;

            // Reset state
            sentCount = 0;
            receivedCount = 0;
            latencies = [];
            sendTimes = new Map();
            testStartTime = Date.now();
            document.getElementById('resultsBody').innerHTML = '';
            updateMetrics();

            testRunning = true;
            document.getElementById('btnRun').disabled = true;
            document.getElementById('btnStop').disabled = false;

            // Resolve queue URLs
            let inputQueueUrl, resultsQueueUrl;
            try {
                setStatus('Resolving queue URLs...');
                inputQueueUrl = await resolveQueueUrl(inputQName);
                resultsQueueUrl = await resolveQueueUrl(resultsQName);
                log('Input queue: ' + inputQueueUrl);
                log('Results queue: ' + resultsQueueUrl);
            } catch (e) {
                log('ERROR resolving queue URLs: ' + e.message);
                log('Make sure your stack is deployed and your Student ID is correct.');
                stopTest();
                return;
            }

            // Generate messages
            log('Generating ' + count + ' opportunities (seed=' + seed + ')...');
            setStatus('Generating messages...');
            const startGen = performance.now();
            generatedMessages = generateOpportunities(count, seed);
            const genMs = (performance.now() - startGen).toFixed(1);
            log('Generated ' + generatedMessages.length + ' messages in ' + genMs + ' ms');

            // Start polling for results
            startPollingWithUrl(resultsQueueUrl);

            // Inject messages in batches of 10
            setStatus('Injecting messages...');
            const batchSize = 10;
            let sent = 0;

            for (let i = 0; i < generatedMessages.length && testRunning; i += batchSize) {
                const batch = generatedMessages.slice(i, i + batchSize);
                const entries = batch.map((msg, idx) => ({
                    Id: String(idx),
                    MessageBody: JSON.stringify(msg),
                }));

                try {
                    const batchSendTime = Date.now();
                    const startSend = performance.now();
                    const result = await sqsClient.sendMessageBatch({
                        QueueUrl: inputQueueUrl,
                        Entries: entries,
                    }).promise();
                    const sendMs = (performance.now() - startSend).toFixed(1);
                    const ok = (result.Successful || []).length;
                    // Record send time for each opportunity in this batch
                    for (const m of batch) {
                        sendTimes.set(m.opportunity_id, batchSendTime);
                    }
                    sent += ok;
                    sentCount = sent;
                    updateMetrics();
                    log('Sent batch ' + Math.ceil((i + 1) / batchSize) + ': ' + ok + ' msgs (' + sendMs + ' ms)');
                } catch (e) {
                    log('ERROR sending batch: ' + e.message);
                }

                // Apply delay between batches
                if (delay > 0 && testRunning) {
                    let actualDelay = delay;
                    if (profile === 'ramp') {
                        const progress = i / generatedMessages.length;
                        actualDelay = Math.max(10, Math.round(delay * (1 - progress)));
                    }
                    await new Promise(r => setTimeout(r, actualDelay));
                }
            }

            setStatus('Injection complete (' + sentCount + ' sent). Waiting for results...');
            log('Injection complete: ' + sentCount + ' messages sent.');
            document.getElementById('btnRun').disabled = false;
        }

        function stopTest() {
            testRunning = false;
            if (pollInterval) {
                if (pollInterval.cancel) pollInterval.cancel();
                else clearInterval(pollInterval);
                pollInterval = null;
            }
            document.getElementById('btnRun').disabled = false;
            document.getElementById('btnStop').disabled = true;
            setStatus('Test stopped.');
            log('Test stopped by user.');
        }

        // =====================================================================
        // Results polling
        // =====================================================================
        async function startPolling() {
            if (!initClients()) return;
            const resultsQName = document.getElementById('resultsQueueUrl').value.trim();
            if (!resultsQName) {
                log('ERROR: No results queue configured.');
                return;
            }
            try {
                const resultsQueueUrl = await resolveQueueUrl(resultsQName);
                startPollingWithUrl(resultsQueueUrl);
            } catch (e) {
                log('ERROR resolving results queue: ' + e.message);
            }
        }

        function startPollingWithUrl(resultsQueueUrl) {
            if (pollInterval) { clearInterval(pollInterval); pollInterval = null; }

            log('Polling results queue (100ms loop)...');
            let polling = true;
            // Store a flag so stopTest can cancel
            pollInterval = { cancel: () => { polling = false; } };

            async function pollOnce() {
                if (!polling) return;
                try {
                    const result = await sqsClient.receiveMessage({
                        QueueUrl: resultsQueueUrl,
                        MaxNumberOfMessages: 10,
                        WaitTimeSeconds: 0,
                    }).promise();

                    const messages = result.Messages || [];
                    if (messages.length > 0) {
                        receivedCount += messages.length;

                        // Delete all messages in parallel for speed
                        const deletePromises = [];
                        for (const msg of messages) {
                            let parsed;
                            try {
                                parsed = JSON.parse(msg.Body);
                            } catch (_) {
                                parsed = {};
                            }

                            // Calculate per-message latency
                            let msgLatencyMs = null;
                            if (parsed.processed_at && parsed.opportunity_id) {
                                const processedTime = new Date(parsed.processed_at).getTime();
                                const sentTime = sendTimes.get(parsed.opportunity_id);
                                if (sentTime && processedTime > 0) {
                                    msgLatencyMs = processedTime - sentTime;
                                    latencies.push(msgLatencyMs);
                                } else if (testStartTime && processedTime > 0) {
                                    msgLatencyMs = processedTime - testStartTime;
                                    latencies.push(msgLatencyMs);
                                }
                            }

                            addResultRow(parsed, msgLatencyMs);

                            deletePromises.push(
                                sqsClient.deleteMessage({
                                    QueueUrl: resultsQueueUrl,
                                    ReceiptHandle: msg.ReceiptHandle,
                                }).promise()
                            );
                        }
                        await Promise.all(deletePromises);
                        updateMetrics();
                    }

                    // Stop polling when all messages are received
                    if (sentCount > 0 && receivedCount >= sentCount) {
                        polling = false;
                        pollInterval = null;
                        setStatus('Test complete: ' + receivedCount + '/' + sentCount + ' results received.');
                        log('All results received. Test complete.');
                        document.getElementById('btnStop').disabled = true;
                        return;
                    }
                } catch (e) {
                    log('Poll error: ' + e.message);
                }

                // Schedule next poll after 100ms
                if (polling) setTimeout(pollOnce, 100);
            }

            pollOnce();
        }

        function addResultRow(msg, latencyMs) {
            const tbody = document.getElementById('resultsBody');
            const tr = document.createElement('tr');

            const oppId = msg.opportunity_id || '--';
            const winner = msg.winning_advertiser_id || '--';
            const bid = msg.winning_bid_amount !== undefined ? '$' + parseFloat(msg.winning_bid_amount).toFixed(2) : '--';
            const score = msg.winning_score !== undefined ? parseFloat(msg.winning_score).toFixed(4) : '--';
            const margin = msg.score_margin !== undefined ? parseFloat(msg.score_margin).toFixed(4) : '--';
            const processed = msg.processed_at || '--';

            // Format latency with color coding
            let latencyStr = '--';
            let latencyColor = '';
            if (latencyMs !== null && latencyMs !== undefined) {
                latencyStr = latencyMs.toFixed(0) + ' ms';
                if (latencyMs < 500) {
                    latencyColor = 'color:#065f46; font-weight:600;'; // green = under target
                } else if (latencyMs < 1000) {
                    latencyColor = 'color:#92400e; font-weight:600;'; // amber = over 500ms
                } else {
                    latencyColor = 'color:#991b1b; font-weight:600;'; // red = over 1s
                }
            }

            tr.innerHTML = '<td class="mono" style="font-size:11px;">' + oppId.substring(0, 8) + '</td>'
                + '<td class="mono" style="font-size:11px;">' + winner + '</td>'
                + '<td>' + bid + '</td>'
                + '<td>' + score + '</td>'
                + '<td>' + margin + '</td>'
                + '<td style="' + latencyColor + '">' + latencyStr + '</td>'
                + '<td class="mono" style="font-size:11px;">' + processed + '</td>';

            // Add to top of table
            if (tbody.firstChild) {
                tbody.insertBefore(tr, tbody.firstChild);
            } else {
                tbody.appendChild(tr);
            }

            // Keep table size reasonable
            while (tbody.children.length > 100) {
                tbody.removeChild(tbody.lastChild);
            }
        }

        // =====================================================================
        // Metrics
        // =====================================================================
        // Rolling buffer of the last 60 latency samples for the sparkline
        let sparkData = [];

        function updateMetrics() {
            document.getElementById('metricSent').textContent = sentCount;
            document.getElementById('metricReceived').textContent = receivedCount;

            if (sentCount > 0) {
                const pct = Math.round((receivedCount / sentCount) * 100);
                const bar = document.getElementById('progressBar');
                bar.style.width = pct + '%';
                bar.textContent = pct + '%';
            }

            if (receivedCount > 0 && testStartTime) {
                const elapsed = (Date.now() - testStartTime) / 1000;
                const throughput = (receivedCount / elapsed).toFixed(1);
                document.getElementById('metricThroughput').textContent = throughput;
            }

            if (latencies.length > 0) {
                const avg = Math.round(latencies.reduce((a, b) => a + b, 0) / latencies.length);
                document.getElementById('metricAvgLatency').textContent = avg + ' ms';
                updatePerfPanel();
            }
        }

        function updatePerfPanel() {
            if (latencies.length === 0) return;
            const sorted = [...latencies].sort((a, b) => a - b);
            const n = sorted.length;
            const mn = sorted[0];
            const mx = sorted[n - 1];
            const avg = sorted.reduce((a, b) => a + b, 0) / n;
            const p95 = sorted[Math.floor(n * 0.95)];

            document.getElementById('perfMin').textContent = mn.toFixed(0) + ' ms';
            document.getElementById('perfAvg').textContent = avg.toFixed(0) + ' ms';
            document.getElementById('perfMax').textContent = mx.toFixed(0) + ' ms';
            document.getElementById('perfP95').textContent = p95.toFixed(0) + ' ms';

            // Latency buckets: fast (<500ms), ok (500–1000ms), slow (>1000ms)
            const fast = latencies.filter(l => l < 500).length;
            const ok = latencies.filter(l => l >= 500 && l < 1000).length;
            const slow = latencies.filter(l => l >= 1000).length;
            const total = latencies.length;
            const pFast = ((fast / total) * 100).toFixed(0);
            const pOk = ((ok / total) * 100).toFixed(0);
            const pSlow = ((slow / total) * 100).toFixed(0);

            document.getElementById('bucketFast').style.width = pFast + '%';
            document.getElementById('bucketOk').style.width = pOk + '%';
            document.getElementById('bucketSlow').style.width = pSlow + '%';
            document.getElementById('bucketFastLbl').textContent = fast > 0 ? pFast + '% <500ms' : '';
            document.getElementById('bucketOkLbl').textContent = ok > 0 ? pOk + '% <1s' : '';
            document.getElementById('bucketSlowLbl').textContent = slow > 0 ? pSlow + '% >1s' : '';

            // Sparkline (last 60 samples)
            sparkData = latencies.slice(-60);
            drawSparkline();
        }

        function drawSparkline() {
            const canvas = document.getElementById('sparkCanvas');
            if (!canvas || sparkData.length < 2) return;
            const ctx = canvas.getContext('2d');
            const W = canvas.width, H = canvas.height;
            ctx.clearRect(0, 0, W, H);

            const maxVal = Math.max(...sparkData, 1000);
            const stepX = W / (sparkData.length - 1);

            // 500ms target line
            const targetY = H - (500 / maxVal) * H;
            ctx.strokeStyle = '#cbd5e1';
            ctx.setLineDash([4, 4]);
            ctx.beginPath(); ctx.moveTo(0, targetY); ctx.lineTo(W, targetY); ctx.stroke();
            ctx.setLineDash([]);

            // Sparkline
            ctx.beginPath();
            sparkData.forEach((val, i) => {
                const x = i * stepX;
                const y = H - (val / maxVal) * H;
                i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
            });
            ctx.strokeStyle = '#3b82f6';
            ctx.lineWidth = 1.5;
            ctx.stroke();
        }

        // =====================================================================
        // Cleanup
        // =====================================================================
        async function purgeInputQueue() {
            if (!initClients()) return;
            const qName = document.getElementById('inputQueueUrl').value.trim();
            if (!qName) { log('ERROR: No input queue.'); return; }
            log('Purging input queue...');
            try {
                const url = await resolveQueueUrl(qName);
                await sqsClient.purgeQueue({ QueueUrl: url }).promise();
                log('Input queue purged.');
            } catch (e) {
                if (e.code === 'AWS.SimpleQueueService.PurgeQueueInProgress') {
                    log('Purge already in progress (SQS allows one per 60 seconds).');
                } else {
                    log('ERROR: ' + e.message);
                }
            }
        }

        async function purgeResultsQueue() {
            if (!initClients()) return;
            const qName = document.getElementById('resultsQueueUrl').value.trim();
            if (!qName) { log('ERROR: No results queue.'); return; }
            log('Purging results queue...');
            try {
                const url = await resolveQueueUrl(qName);
                await sqsClient.purgeQueue({ QueueUrl: url }).promise();
                log('Results queue purged.');
            } catch (e) {
                if (e.code === 'AWS.SimpleQueueService.PurgeQueueInProgress') {
                    log('Purge already in progress (SQS allows one per 60 seconds).');
                } else {
                    log('ERROR: ' + e.message);
                }
            }
        }

        async function cleanupTable() {
            if (!initClients()) return;
            const tableName = document.getElementById('tableName').value.trim();
            if (!tableName) { log('ERROR: No table name.'); return; }

            log('Recreating DynamoDB table (this may take 30-60 seconds)...');
            setStatus('Recreating DynamoDB table...');

            try {
                // Delete existing table
                try {
                    await dynamoClient.deleteTable({ TableName: tableName }).promise();
                    log('Deleting table...');
                    await dynamoClient.waitFor('tableNotExists', { TableName: tableName }).promise();
                    log('Table deleted.');
                } catch (e) {
                    if (e.code !== 'ResourceNotFoundException') throw e;
                    log('Table does not exist, creating fresh.');
                }

                // Recreate
                await dynamoClient.createTable({
                    TableName: tableName,
                    AttributeDefinitions: [
                        { AttributeName: 'opportunity_id', AttributeType: 'S' },
                    ],
                    KeySchema: [
                        { AttributeName: 'opportunity_id', KeyType: 'HASH' },
                    ],
                    BillingMode: 'PAY_PER_REQUEST',
                }).promise();
                await dynamoClient.waitFor('tableExists', { TableName: tableName }).promise();
                log('Table recreated: ' + tableName);
                setStatus('Table recreated.');
            } catch (e) {
                log('ERROR: ' + e.message);
                setStatus('Table cleanup failed.');
            }
        }

        async function fullCleanup() {
            log('Running full cleanup...');
            await purgeInputQueue();
            await purgeResultsQueue();
            await cleanupTable();
            sentCount = 0;
            receivedCount = 0;
            latencies = [];
            document.getElementById('resultsBody').innerHTML = '';
            updateMetrics();
            document.getElementById('progressBar').style.width = '0%';
            document.getElementById('progressBar').textContent = '0%';
            log('Full cleanup complete.');
            setStatus('Ready.');
        }

        // =====================================================================
        // Save / Load Config (localStorage)
        // =====================================================================
        const STORAGE_KEY = 'adflow_test_config';

        function saveConfig() {
            const config = {
                accessKeyId: document.getElementById('accessKeyId').value.trim(),
                secretAccessKey: document.getElementById('secretAccessKey').value.trim(),
                region: document.getElementById('region').value,
                studentId: document.getElementById('studentId').value.trim(),
                seed: document.getElementById('seed').value,
            };
            try {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(config));
                document.getElementById('saveStatus').textContent = 'Saved!';
                setTimeout(() => document.getElementById('saveStatus').textContent = '', 3000);
                log('Config saved to browser local storage.');
            } catch (e) {
                log('ERROR saving config: ' + e.message);
            }
        }

        function clearSavedConfig() {
            localStorage.removeItem(STORAGE_KEY);
            document.getElementById('saveStatus').textContent = 'Cleared.';
            setTimeout(() => document.getElementById('saveStatus').textContent = '', 3000);
            log('Saved config cleared from browser local storage.');
        }

        function loadSavedConfig() {
            try {
                const raw = localStorage.getItem(STORAGE_KEY);
                if (!raw) return;
                const config = JSON.parse(raw);
                if (config.accessKeyId) document.getElementById('accessKeyId').value = config.accessKeyId;
                if (config.secretAccessKey) document.getElementById('secretAccessKey').value = config.secretAccessKey;
                if (config.region) document.getElementById('region').value = config.region;
                if (config.studentId) {
                    document.getElementById('studentId').value = config.studentId;
                    updateConfig();
                }
                if (config.seed) document.getElementById('seed').value = config.seed;
                log('Loaded saved config from browser local storage.');
            } catch (e) {
                // Silently ignore parse errors
            }
        }

        // =====================================================================
        // DynamoDB Table Viewer
        // =====================================================================
        async function scanDynamoTable() {
            if (!initClients()) return;
            const tableName = document.getElementById('tableName').value.trim();
            if (!tableName) {
                log('ERROR: No table name. Enter your Student ID first.');
                return;
            }

            const statusEl = document.getElementById('scanStatus');
            const tbody = document.getElementById('dynamoBody');
            tbody.innerHTML = '';
            statusEl.textContent = 'Scanning...';
            log('Scanning DynamoDB table: ' + tableName + '...');

            try {
                let items = [];
                let lastKey = undefined;

                do {
                    const params = {
                        TableName: tableName,
                    };
                    if (lastKey) params.ExclusiveStartKey = lastKey;

                    const result = await dynamoClient.scan(params).promise();
                    items = items.concat(result.Items || []);
                    lastKey = result.LastEvaluatedKey;
                    statusEl.textContent = 'Scanning... (' + items.length + ' items so far)';
                } while (lastKey);

                statusEl.textContent = items.length + ' items found.';
                log('Scan complete: ' + items.length + ' items in table ' + tableName);

                // Helper to extract DynamoDB attribute value
                function dv(attr) {
                    if (!attr) return '--';
                    if (attr.S) return attr.S;
                    if (attr.N) return attr.N;
                    if (attr.BOOL !== undefined) return String(attr.BOOL);
                    return JSON.stringify(attr);
                }

                // Sort by processed_at descending
                items.sort((a, b) => {
                    const ta = dv(a.processed_at);
                    const tb = dv(b.processed_at);
                    return tb.localeCompare(ta);
                });

                for (const item of items) {
                    const tr = document.createElement('tr');
                    const oppId = dv(item.opportunity_id);
                    tr.innerHTML = '<td class="mono" style="font-size:11px;">' + oppId.substring(0, 8) + '</td>'
                        + '<td class="mono" style="font-size:11px;">' + dv(item.winning_advertiser_id) + '</td>'
                        + '<td>$' + parseFloat(dv(item.winning_bid_amount) || 0).toFixed(2) + '</td>'
                        + '<td>' + parseFloat(dv(item.winning_score) || 0).toFixed(4) + '</td>'
                        + '<td>' + parseFloat(dv(item.score_margin) || 0).toFixed(4) + '</td>'
                        + '<td>' + dv(item.content_category) + '</td>'
                        + '<td>' + dv(item.region) + '</td>'
                        + '<td>' + dv(item.device_type) + '</td>'
                        + '<td>' + dv(item.num_bids) + '</td>'
                        + '<td class="mono" style="font-size:11px;">' + dv(item.processed_at) + '</td>';
                    tbody.appendChild(tr);
                }
            } catch (e) {
                statusEl.textContent = 'Error: ' + e.code;
                log('ERROR scanning table: ' + e.message);
            }
        }

        // Initialize
        loadSavedConfig();
        updateProfile();
    </script>

</body>

</html>